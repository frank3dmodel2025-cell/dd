<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visor 3D Minimalista</title>
    
    <!-- Scripts de Tailwind, Three.js y OrbitControls -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/GLTFLoader.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        /* Base styles and custom scrollbar for minimalist theme */
        body {
            font-family: 'Poppins', sans-serif; /* Fuente moderna */
            background-color: #f7f3ed; /* Fondo crema muy claro */
            color: #3b4233; /* Texto oscuro suave */
            overflow: hidden; /* Prevent scrolling */
        }
        
        /* Glassmorphism para paneles */
        .glass-panel-minimal {
            background-color: rgba(255, 255, 255, 0.7); /* Blanco lechoso semitransparente */
            backdrop-filter: blur(10px); /* Desenfoque suave */
            border: 1px solid rgba(255, 255, 255, 0.4); /* Borde muy sutil */
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.08); /* Sombra suave y difuminada */
            border-radius: 2rem; /* Bordes muy redondeados */
        }
        
        /* Custom scrollbar for minimalist panel */
        .glass-panel-minimal::-webkit-scrollbar {
            width: 8px;
        }
        .glass-panel-minimal::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
            border-radius: 10px;
        }
        .glass-panel-minimal::-webkit-scrollbar-thumb {
            background: #9fbe89; /* Verde suave de acento */
            border-radius: 10px;
        }
        .glass-panel-minimal::-webkit-scrollbar-thumb:hover {
            background: #8aa97a;
        }

        /* Botones con estilo minimalista */
        .minimal-btn {
            background-color: #9fbe89; /* Verde suave de acento */
            color: #ffffff;
            border: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); /* Sombra más pronunciada */
            border-radius: 1rem; /* Bordes redondeados */
            padding: 0.75rem 1.25rem;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s ease-in-out;
            text-align: center; /* Asegurar centrado para botones full-width */
        }
        .minimal-btn:hover {
            background-color: #8aa97a;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
            transform: translateY(-2px);
        }
        .minimal-btn:active {
            background-color: #769469;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transform: translateY(0);
        }

        /* Carrusel con estilo minimalista */
        .carousel-minimal-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            min-width: 6rem; /* Asegurar que no se haga demasiado pequeño */
        }
        .carousel-minimal-item > div {
            border: 1px solid rgba(0, 0, 0, 0.1);
            background-color: #f0ede8; /* Fondo claro para items inactivos */
            border-radius: 0.75rem; /* Redondeado suave */
            font-size: 0.75rem;
            color: #5c6c4e; /* Texto suave */
            transition: all 0.2s ease-in-out;
            padding: 0.5rem; /* Pequeño padding para el contenido del item */
        }
        .carousel-minimal-item.active > div {
            border-color: #9fbe89 !important; /* Borde de acento para activo */
            background-color: #9fbe89; /* Fondo de acento para activo */
            color: #ffffff;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        .carousel-minimal-item span {
            font-size: 0.8rem;
            color: #5c6c4e;
            margin-top: 0.5rem;
        }

        /* Alerta minimalista */
        #alert-box.minimal-alert {
            background-color: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border-radius: 1.5rem;
            padding: 1.2rem 1.5rem;
        }
        
        /* Reglas de Media Query para Movil (sm o menos) */
        @media (max-width: 768px) {
            
            /* Panel de Control Móvil */
            #control-panel {
                /* Posicionamiento en móvil: Ocupa el ancho completo */
                width: calc(100vw - 2rem); 
                height: 75vh; /* Máximo 75% de la altura visible */
                top: 1rem; /* Margen superior */
                left: 1rem; /* Margen izquierdo */
                right: 1rem; /* Margen derecho */
                transform: translateX(calc(-100% - 2rem)) !important; /* Ocultar a la izquierda (ajustado por padding) */
                z-index: 30; /* Subir z-index para que cubra todo */
            }

            /* Mostrar panel */
            #control-panel.is-visible {
                transform: translateX(0) !important;
            }
            
            /* Botón de Menú */
            #menu-toggle-btn {
                z-index: 50; /* Asegurar que el botón esté sobre el panel */
                top: 0.75rem;
                left: 0.75rem;
            }

            /* Carrusel de Modelos Móvil */
            #carousel {
                /* Centrado horizontal como antes */
                width: calc(100% - 2rem);
                /* Ajustar padding para que se vea bien en móvil */
                padding: 1rem; 
                overflow-x: auto; /* Permitir scroll horizontal si hay muchos modelos */
                justify-content: flex-start; /* Alinear items al inicio */
            }
            
            /* Contenedor de modelos dentro del carrusel, forzando scroll */
            #carousel > div {
                flex-wrap: nowrap; /* Evitar que los ítems salten de línea */
                padding-bottom: 0.5rem;
            }
        }
    </style>
    <script>
        // Configuración de Tailwind para colores personalizados
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'light-bg': '#f7f3ed',     // Fondo crema principal
                        'panel-bg': 'rgba(255, 255, 255, 0.7)', // Fondo de paneles con transparencia
                        'accent-color': '#9fbe89', // Verde suave de acento
                        'text-dark-soft': '#3b4233', // Texto oscuro suave
                        'text-light-soft': '#5c6c4e', // Texto secundario suave
                    }
                }
            }
        }
    </script>
</head>
<body class="bg-light-bg text-text-dark-soft">

    <!-- Contenedor Principal -->
    <div id="app-container" class="w-screen h-screen relative">
        
        <!-- Contenedor del Canvas 3D (Ocupa todo el fondo) -->
        <div id="three-canvas-container" class="w-full h-full"></div>

        <!-- Caja de Alerta Minimalista (Se mantiene centrada) -->
        <div id="alert-box" class="minimal-alert fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 p-4 z-50 transition-opacity duration-300 pointer-events-none opacity-0"
            role="alert">
            <p id="alert-message" class="text-text-dark-soft font-medium"></p>
        </div>

        <!-- Botón de Menú (Responsive: se queda arriba a la izquierda) -->
        <button id="menu-toggle-btn"
            class="fixed top-4 left-4 p-3 bg-white shadow-lg hover:shadow-xl transition duration-200 z-30"
            onclick="togglePanelVisibility()">
            <!-- Icono de Menú -->
            <svg id="menu-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6 text-text-dark-soft">
                <line x1="4" y1="12" x2="20" y2="12"></line>
                <line x1="4" y1="6" x2="20" y2="6"></line>
                <line x1="4" y1="18" x2="20" y2="18"></line>
            </svg>
            <!-- Icono de Cierre (X) -->
            <svg id="close-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6 text-text-dark-soft hidden">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
        </button>


        <!-- Panel de Control (Desktop: Fijo a la izquierda, Móvil: Deslizable desde la izquierda) -->
        <div id="control-panel"
             class="glass-panel-minimal fixed top-4 left-4 
                    w-72 md:h-[calc(100vh-2rem)] p-6 z-20 
                    transform -translate-x-full md:translate-x-0 md:w-72 md:h-[calc(100vh-2rem)]
                    transition-transform duration-300 overflow-y-auto">
            
            <h2 class="text-2xl font-semibold mb-6 text-accent-color">Controles 3D</h2>

            <!-- Modelo Actual -->
            <div class="mb-6 pb-4 border-b border-gray-200">
                <p class="text-sm text-text-light-soft mb-1">Modelo Actual:</p>
                <p id="current-model-name" class="text-xl font-medium">Duck</p>
            </div>

            <!-- Navegación -->
            <div class="mb-6">
                <h3 class="text-lg font-medium mb-3 border-b border-gray-200 pb-1">Navegación</h3>
                <div class="grid grid-cols-2 gap-3">
                    <button class="minimal-btn" onclick="zoomCamera(1.1)">
                        Zoom +
                    </button>
                    <button class="minimal-btn" onclick="zoomCamera(0.9)">
                        Zoom -
                    </button>
                </div>
            </div>

            <!-- Escala -->
            <div class="mb-6">
                <h3 class="text-lg font-medium mb-3 border-b border-gray-200 pb-1">Escala</h3>
                <div class="grid grid-cols-2 gap-3">
                    <button class="minimal-btn" onclick="scaleModel(1.2)">
                        Escala +
                    </button>
                    <button class="minimal-btn" onclick="scaleModel(0.8)">
                        Escala -
                    </button>
                </div>
            </div>

            <!-- Modos -->
            <div class="mb-6">
                <h3 class="text-lg font-medium mb-3 border-b border-gray-200 pb-1">Modos</h3>
                <div class="space-y-3">
                    <button id="toggle-rotate-btn" class="minimal-btn w-full" onclick="toggleAutoRotate()">
                        Rotación Automática: <span id="auto-rotate-status">OFF</span>
                    </button>
                    <button id="toggle-lock-btn" class="minimal-btn w-full" onclick="toggleLockModel()">
                        Bloquear Modelo: <span id="lock-status">OFF</span>
                    </button>
                </div>
            </div>

            <!-- Simulación AR -->
            <div class="mb-6">
                <h3 class="text-lg font-medium mb-3 border-b border-gray-200 pb-1">Simulación AR</h3>
                <button id="toggle-placement-btn" class="minimal-btn w-full bg-orange-400 hover:bg-orange-500" onclick="togglePlacementMode()">
                    Modo Pared (AR): <span id="placement-status">OFF</span>
                </button>
                <p class="text-xs text-gray-500 mt-2 italic">Requiere permiso de la cámara.</p>
            </div>
            
            <!-- Controles de Posición (AR) -->
            <div id="placement-controls" class="space-y-3 pt-4 border-t border-gray-200 hidden">
                <h3 class="text-lg font-medium text-orange-500">Ajuste de Posición (AR)</h3>
                <p class="text-sm text-text-light-soft">Mueve el modelo para alinearlo.</p>
                
                <!-- Movimiento X -->
                <div class="flex flex-col">
                    <span class="text-sm mb-1 text-text-light-soft">Movimiento Horizontal (X)</span>
                    <div class="grid grid-cols-2 gap-3">
                        <button class="minimal-btn bg-orange-400/80 hover:bg-orange-500" onclick="moveModel('x', -0.1)">
                            ← Izquierda
                        </button>
                        <button class="minimal-btn bg-orange-400/80 hover:bg-orange-500" onclick="moveModel('x', 0.1)">
                            Derecha →
                        </button>
                    </div>
                </div>

                <!-- Movimiento Y -->
                <div class="flex flex-col">
                    <span class="text-sm mb-1 text-text-light-soft">Movimiento Vertical (Y)</span>
                    <div class="grid grid-cols-2 gap-3">
                        <button class="minimal-btn bg-orange-400/80 hover:bg-orange-500" onclick="moveModel('y', 0.1)">
                            ↑ Arriba
                        </button>
                        <button class="minimal-btn bg-orange-400/80 hover:bg-orange-500" onclick="moveModel('y', -0.1)">
                            Abajo ↓
                        </button>
                    </div>
                </div>
                
                <!-- Rotación Z -->
                <div class="flex flex-col">
                    <span class="text-sm mb-1 text-text-light-soft">Rotación (Inclinación Z)</span>
                    <div class="grid grid-cols-2 gap-3">
                        <button class="minimal-btn bg-purple-400/80 hover:bg-purple-500" onclick="rotateModel('z', 0.05)">
                            Giro Izq.
                        </button>
                        <button class="minimal-btn bg-purple-400/80 hover:bg-purple-500" onclick="rotateModel('z', -0.05)">
                            Giro Der.
                        </button>
                    </div>
                </div>
            </div>
            
            <div class="text-center mt-8">
                <p class="text-sm text-gray-400">Visor 3D Propulsado por Three.js</p>
            </div>

        </div>

        <!-- Carrusel de Modelos (Siempre visible, Responsive: Fijo en la parte inferior) -->
        <div id="carousel"
             class="glass-panel-minimal fixed bottom-4 left-1/2 transform -translate-x-1/2 p-4 z-20 
                    flex flex-col md:flex-row space-y-3 md:space-y-0 md:space-x-4 
                    w-[90%] md:w-auto transition-opacity duration-300 opacity-100 pointer-events-auto">
            
            <h3 class="text-base font-medium my-auto pr-4 border-b md:border-b-0 md:border-r border-gray-200 pb-2 md:pb-0 text-text-light-soft">Modelos</h3>

            <!-- Contenedor de Ítems del Carrusel (permite scroll horizontal en móvil) -->
            <div class="flex space-x-3 overflow-x-auto overflow-y-hidden">
                <button class="carousel-minimal-item" data-model="Duck" onclick="selectModel('Duck')">
                    <div class="w-16 h-16 flex items-center justify-center font-semibold transition-all">
                        Pato
                    </div>
                    <span class="mt-1">Duck</span>
                </button>
                <button class="carousel-minimal-item" data-model="Helmet" onclick="selectModel('Helmet')">
                    <div class="w-16 h-16 flex items-center justify-center font-semibold transition-all">
                        Casco
                    </div>
                    <span class="mt-1">Helmet</span>
                </button>
                <button class="carousel-minimal-item" data-model="BoomBox" onclick="selectModel('BoomBox')">
                    <div class="w-16 h-16 flex items-center justify-center font-semibold transition-all">
                        Bocina
                    </div>
                    <span class="mt-1">BoomBox</span>
                </button>
            </div>
        </div>

    </div>

    <script>
        // --- Variables de Three.js y Configuración de Posición ---
        let scene, camera, renderer, controls;
        let loader, currentModel = null;
        let video = null; // Para el fondo AR
        let videoTexture = null;
        
        let isPlacementModeActive = false; // Estado global para el modo pared

        // Rutas de los modelos glTF de ejemplo de Khronos (pueden requerir CORS)
        const MODEL_PATHS = {
            'Duck': 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Duck/glTF/Duck.gltf',
            'Helmet': 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/DamagedHelmet/glTF/DamagedHelmet.gltf',
            'BoomBox': 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/BoomBox/glTF/BoomBox.gltf'
        };

        // Constantes para posiciones de Cámara y Target
        const DEFAULT_CAMERA_POS = new THREE.Vector3(0, 1.5, 4);
        const DEFAULT_TARGET_POS = new THREE.Vector3(0, 0, 0);

        // Configuración para el "Modo Pared" (Ilusión AR)
        const PLACEMENT_CAMERA_POS = new THREE.Vector3(0, 1.3, 0.5); 
        const PLACEMENT_TARGET_POS = new THREE.Vector3(0, 1.3, -2.5); 
        const PLACEMENT_MODEL_OFFSET = new THREE.Vector3(0, 0, -2.5); 

        // Estado del UI
        let isPanelVisible = false;

        // --- Inicialización de Three.js ---
        function initThree() {
            // 1. Configuración de la Escena
            scene = new THREE.Scene();

            // 2. Configuración de la Cámara
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.copy(DEFAULT_CAMERA_POS); // Posición inicial

            // 3. Configuración del Renderizador
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); // Antialiasing ON para suavidad
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('three-canvas-container').appendChild(renderer.domElement);

            // 4. Iluminación
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            // 5. Controles de Órbita
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.target.copy(DEFAULT_TARGET_POS);

            // 6. Loader
            loader = new THREE.GLTFLoader();

            // 7. Manejo de Redimensionamiento
            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Bucle de Animación ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // Necesario si controls.enableDamping está activado
            if (videoTexture) videoTexture.needsUpdate = true; // Actualizar textura de video si está activa
            renderer.render(scene, camera);
        }
        
        // --- Funcionalidad de Carga de Modelos ---
        function loadModel(url, modelName) {
            alertMessage(`Cargando modelo: ${modelName}...`);

            // 1. Remover modelo anterior
            if (currentModel) {
                scene.remove(currentModel);
                currentModel = null;
            }

            // 2. Cargar nuevo modelo
            loader.load(
                url,
                (gltf) => {
                    currentModel = gltf.scene;
                    
                    // Centrar y escalar el modelo para que encaje
                    const box = new THREE.Box3().setFromObject(currentModel);
                    const size = box.getSize(new THREE.Vector3()).length();
                    const center = box.getCenter(new THREE.Vector3());
                    
                    currentModel.position.sub(center); // Centrar el pivote del modelo en (0,0,0)

                    // Escalar el modelo para que se vea bien
                    const scaleFactor = 4 / size; 
                    currentModel.scale.set(scaleFactor, scaleFactor, scaleFactor);
                    
                    scene.add(currentModel);
                    
                    // Si el modo pared está activo, aplicar inmediatamente el desplazamiento
                    if (isPlacementModeActive) {
                        currentModel.position.copy(PLACEMENT_MODEL_OFFSET);
                    } else {
                        // Asegurar posición central en modo normal
                        currentModel.position.set(0, 0, 0);
                    }

                    alertMessage(`Modelo "${modelName}" cargado con éxito.`);
                },
                (xhr) => {
                    // Progreso de carga
                    // console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                },
                (error) => {
                    console.error('Error cargando modelo:', error);
                    alertMessage(`ERROR: No se pudo cargar el modelo "${modelName}".`, 'error');
                }
            );
        }

        function selectModel(modelName) {
            const url = MODEL_PATHS[modelName];
            if (url) {
                loadModel(url, modelName);
                document.getElementById('current-model-name').textContent = modelName;
                
                // Actualizar estilo del carrusel para indicar el modelo activo
                document.querySelectorAll('.carousel-minimal-item').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelector(`[data-model="${modelName}"]`).classList.add('active');

            } else {
                alertMessage('Modelo no encontrado.', 'error');
            }
        }

        // --- Funcionalidad de Controles UI ---
        
        // 1. Alternar Visibilidad del Panel y Carrusel
        function togglePanelVisibility() {
            const panel = document.getElementById('control-panel');
            const menuIcon = document.getElementById('menu-icon');
            const closeIcon = document.getElementById('close-icon');
            
            // Determinar si es un dispositivo móvil (ancho menor a 768px)
            const isMobile = window.innerWidth < 768; 
            
            isPanelVisible = !isPanelVisible;

            if (isPanelVisible) {
                // Mostrar panel
                // En móvil, se aplica la clase 'is-visible' (ver CSS)
                if (isMobile) {
                    panel.classList.add('is-visible');
                } else {
                    // En desktop, se usa la clase de Tailwind
                    panel.classList.remove('-translate-x-full');
                }

                menuIcon.classList.add('hidden');
                closeIcon.classList.remove('hidden');
            } else {
                // Ocultar panel
                 if (isMobile) {
                    panel.classList.remove('is-visible');
                } else {
                    panel.classList.add('-translate-x-full');
                }
                
                menuIcon.classList.remove('hidden');
                closeIcon.classList.add('hidden');
            }
        }

        // 2. Zoom de Cámara (Aplica en ambos modos, afectando la distancia al target)
        function zoomCamera(factor) {
            if (!controls) return;
            
            // Usar la posición actual como referencia, manteniendo el target
            const currentDistance = camera.position.distanceTo(controls.target);
            const newDistance = currentDistance * factor;
            
            // Límite para evitar zoom excesivo
            if (newDistance > 0.5 && newDistance < 100) {
                const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
                camera.position.copy(controls.target).add(direction.multiplyScalar(newDistance));
                controls.update();
                alertMessage(factor > 1 ? 'Acercando Zoom' : 'Alejando Zoom');
            } else {
                alertMessage('Límite de Zoom alcanzado.', 'info');
            }
        }

        // 3. Escala del Modelo
        function scaleModel(factor) {
            if (!currentModel) {
                alertMessage('Cargue un modelo primero.', 'warning');
                return;
            }
            currentModel.scale.multiplyScalar(factor);
            alertMessage(factor > 1 ? 'Aumentando Escala' : 'Reduciendo Escala');
        }

        // 4. Rotación Automática
        function toggleAutoRotate() {
            controls.autoRotate = !controls.autoRotate;
            const statusText = controls.autoRotate ? 'ON' : 'OFF';
            document.getElementById('auto-rotate-status').textContent = statusText;
            alertMessage(`Rotación Automática: ${statusText}`);
        }

        // 5. Bloquear Modelo (Desactivar OrbitControls)
        function toggleLockModel() {
            // Solo se permite bloquear/desbloquear en modo normal
            if (isPlacementModeActive) {
                alertMessage('El control de órbita está bloqueado en Modo Pared.', 'warning');
                return;
            }
            
            controls.enabled = !controls.enabled;
            const statusText = controls.enabled ? 'OFF' : 'ON'; // ON cuando controls está DESHABILITADO
            document.getElementById('lock-status').textContent = controls.enabled ? 'OFF' : 'ON';
            alertMessage(`Modelo Bloqueado: ${controls.enabled ? 'NO' : 'SÍ'}`);
        }
        
        // ** NUEVAS FUNCIONES DE AJUSTE MANUAL **
        
        // Mueve el modelo en el eje X, Y o Z.
        function moveModel(axis, distance) {
            if (!currentModel || !isPlacementModeActive) {
                alertMessage('Active el Modo Pared primero.', 'warning');
                return;
            }
            // Mover en los ejes locales del modelo
            currentModel.position[axis] += distance;
            alertMessage(`Moviendo en ${axis.toUpperCase()} por ${distance > 0 ? '+' : ''}${distance.toFixed(1)}`);
        }

        // Rota el modelo en el eje X, Y o Z.
        function rotateModel(axis, angle) {
            if (!currentModel || !isPlacementModeActive) {
                alertMessage('Active el Modo Pared primero.', 'warning');
                return;
            }
            // Rotar alrededor del eje (usamos Z para inclinación en una pared)
            currentModel.rotation[axis] += angle;
            alertMessage(`Rotando en ${axis.toUpperCase()} por ${angle > 0 ? '+' : ''}${angle.toFixed(2)}`);
        }
        
        // 6. Modo Pared (Simulación AR)
        async function togglePlacementMode() {
            const btn = document.getElementById('toggle-placement-btn');
            const status = document.getElementById('placement-status');
            const placementControls = document.getElementById('placement-controls');

            if (isPlacementModeActive) {
                // --- Desactivar Modo Colocación ---
                isPlacementModeActive = false;
                
                // 1. Detener Video/Cámara
                if (video && video.srcObject) {
                    video.srcObject.getTracks().forEach(track => track.stop());
                }
                video = null;
                videoTexture = null;

                // 2. Restaurar Escena
                scene.background = new THREE.Color(0xf7f3ed); // Fondo del tema minimalista
                
                // 3. Restaurar Cámara, Controles y Modelo
                controls.enabled = true; // Restaurar control de órbita
                camera.position.copy(DEFAULT_CAMERA_POS);
                controls.target.copy(DEFAULT_TARGET_POS);
                controls.update();
                if (currentModel) {
                    currentModel.position.set(0, 0, 0);
                    currentModel.rotation.set(0, 0, 0); // Resetear rotación para el modo normal
                }
                
                // 4. Actualizar UI
                status.textContent = 'OFF';
                btn.classList.remove('bg-green-600', 'hover:bg-green-500'); // Cambiar a color original
                btn.classList.add('bg-orange-400', 'hover:bg-orange-500');
                placementControls.classList.add('hidden'); // Ocultar controles de ajuste
                alertMessage('Modo Pared Desactivado.');

            } else {
                // --- Activar Modo Colocación ---
                try {
                    // 1. Iniciar Video/Cámara
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: 'environment' } 
                    });
                    
                    video = document.createElement('video');
                    video.srcObject = stream;
                    video.play();
                    
                    videoTexture = new THREE.VideoTexture(video);
                    
                    // 2. Configurar Escena para AR Illusion
                    scene.background = videoTexture;
                    
                    // 3. Configurar Cámara, Controles y Modelo
                    controls.enabled = false; // Bloquear control de órbita para la ilusión AR
                    
                    if (currentModel) currentModel.position.copy(PLACEMENT_MODEL_OFFSET);
                    camera.position.copy(PLACEMENT_CAMERA_POS);
                    controls.target.copy(PLACEMENT_TARGET_POS);
                    controls.update();

                    // 4. Actualizar UI
                    isPlacementModeActive = true;
                    status.textContent = 'ON';
                    btn.classList.remove('bg-orange-400', 'hover:bg-orange-500'); // Cambiar a color activo
                    btn.classList.add('bg-green-600', 'hover:bg-green-500');
                    placementControls.classList.remove('hidden'); // Mostrar controles de ajuste
                    alertMessage('Modo Pared Activado (Cámara en uso).', 'success');

                } catch (err) {
                    console.error('Error al acceder a la cámara:', err);
                    alertMessage('ERROR: No se pudo acceder a la cámara o permisos denegados.', 'error');
                }
            }
        }


        // 7. Sistema de Alerta Personalizada
        let alertTimeout = null;
        function alertMessage(message, type = 'info') {
            const alertBox = document.getElementById('alert-box');
            const alertMsg = document.getElementById('alert-message');

            // Limpiar timeout anterior
            if (alertTimeout) {
                clearTimeout(alertTimeout);
            }

            // Aplicar estilo basado en el tipo
            alertBox.className = 'minimal-alert fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 p-4 z-50 transition-opacity duration-300 pointer-events-none opacity-0';
            
            if (type === 'success') {
                alertBox.classList.add('border-green-300/50');
                alertMsg.innerHTML = `<span class="text-green-300 mr-2">✓</span> ${message}`;
            } else if (type === 'error') {
                alertBox.classList.add('border-red-300/50');
                alertMsg.innerHTML = `<span class="text-red-300 mr-2">✗</span> ${message}`;
            } else if (type === 'warning') {
                alertBox.classList.add('border-yellow-300/50');
                alertMsg.innerHTML = `<span class="text-yellow-300 mr-2">!</span> ${message}`;
            } else {
                alertBox.classList.add('border-gray-300/50');
                alertMsg.innerHTML = message;
            }

            // Mostrar
            alertBox.classList.remove('opacity-0', 'pointer-events-none');
            alertBox.classList.add('opacity-100', 'pointer-events-auto');

            // Ocultar automáticamente después de 3 segundos
            alertTimeout = setTimeout(() => {
                alertBox.classList.remove('opacity-100', 'pointer-events-auto');
                alertBox.classList.add('opacity-0', 'pointer-events-none');
            }, 3000);
        }


        // --- Ejecución Principal ---
        window.onload = function() {
            initThree();
            selectModel('Duck'); // Cargar modelo por defecto

            // Lógica para determinar el estado inicial de visibilidad del panel
            const panel = document.getElementById('control-panel');
            const isMobile = window.innerWidth < 768; 
            
            // Si es móvil, el panel debe estar completamente oculto inicialmente.
            if (isMobile) {
                // El CSS ya lo oculta con transform: translateX(calc(-100% - 2rem))
                isPanelVisible = false;
                panel.classList.remove('md:translate-x-0'); // Asegura que no se muestre en móvil
            } else {
                // En desktop, el panel debe estar visible por defecto.
                isPanelVisible = true;
                panel.classList.remove('-translate-x-full'); // Mostrar panel en desktop
                panel.classList.add('md:translate-x-0'); 
                
                // Ocultar icono de cierre y mostrar el de menú (en desktop visible)
                document.getElementById('menu-icon').classList.add('hidden');
                document.getElementById('close-icon').classList.remove('hidden');
            }

            // El carrusel siempre debe estar visible por defecto (responsive)
            // Ya no es necesario manejar la opacidad aquí, el CSS lo hace por defecto.

            document.getElementById('placement-controls').classList.add('hidden'); // Ocultar controles AR
            
            animate();
        };

    </script>
</body>
</html>
