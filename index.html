<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AR Fallback - Tap to Place + Gyro</title>
  <style>
    html,body { height:100%; margin:0; overflow:hidden; font-family: Arial, sans-serif; background:#000; }
    #ui {
      position: absolute; left:12px; top:12px; z-index:14;
      color:white; background: rgba(0,0,0,0.35); padding:8px 12px; border-radius:8px; font-size:14px;
    }
    video#cameraFeed { position: fixed; inset:0; width:100%; height:100%; object-fit:cover; z-index:0; display:none; }
    canvas { position: absolute; inset:0; z-index:1; touch-action: none; }
    .btn { padding:8px 10px; margin-left:6px; border-radius:6px; border:0; background:#1f8; color:#022; font-weight:600; cursor:pointer; }
  </style>
</head>
<body>
  <div id="ui">
    <span id="status">Modo AR fallback</span>
    <button id="startCam" class="btn">Activar Cámara</button>
    <button id="requestGyro" class="btn">Permitir Giroscopio</button>
  </div>
  <video id="cameraFeed" autoplay playsinline></video>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.module.js';
    import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.150.0/examples/jsm/loaders/GLTFLoader.js';
    import { DeviceOrientationControls } from 'https://cdn.jsdelivr.net/npm/three@0.150.0/examples/jsm/controls/DeviceOrientationControls.js';

    // CONFIG
    const MODEL_URL = 'https://cdn.jsdelivr.net/gh/KhronosGroup/glTF-Sample-Models@master/2.0/Duck/glTF/Duck.gltf';
    // ------------

    let scene, camera, renderer, controls, model;
    let modelPlaced = false;
    const cameraFeed = document.getElementById('cameraFeed');
    const statusEl = document.getElementById('status');

    init();
    animate();

    function init(){
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 50);

      renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // lights
      const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2);
      scene.add(hemi);
      const dir = new THREE.DirectionalLight(0xffffff, 0.6);
      dir.position.set(3,10,10);
      scene.add(dir);

      // GLTF
      const loader = new GLTFLoader();
      loader.load(MODEL_URL, (gltf) => {
        model = gltf.scene;
        model.scale.setScalar(0.6);
        model.visible = false;
        // Añadimos una "sombra" como sprite (gradiente)
        const canvas = document.createElement('canvas');
        canvas.width = canvas.height = 256;
        const ctx = canvas.getContext('2d');
        const g = ctx.createRadialGradient(128,128,10,128,128,128);
        g.addColorStop(0, 'rgba(0,0,0,0.6)');
        g.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = g;
        ctx.fillRect(0,0,256,256);
        const tex = new THREE.CanvasTexture(canvas);
        const spriteMat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthWrite: false });
        const shadow = new THREE.Sprite(spriteMat);
        shadow.name = 'shadow';
        shadow.scale.set(1.6,1.6,1);
        shadow.position.set(0, -0.9, 0); // debajo del centro del modelo (ajusta según modelo)
        model.add(shadow);
        scene.add(model);
      });

      // DeviceOrientationControls (gyro)
      controls = new DeviceOrientationControls(camera);
      // NOTA: en iOS moderno se necesita pedir permiso antes de usar DeviceOrientationEvent.
      // Proporcionamos botón para solicitar permiso.
      document.getElementById('requestGyro').addEventListener('click', async () => {
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
          try {
            const perm = await DeviceOrientationEvent.requestPermission();
            if (perm === 'granted') {
              controls.connect();
              statusEl.textContent = 'Giroscopio activo';
            } else {
              statusEl.textContent = 'Permiso giroscopio denegado';
            }
          } catch (e) {
            console.warn('requestPermission error', e);
            statusEl.textContent = 'No se pudo solicitar permiso giroscopio';
          }
        } else {
          // navegadores que no requieren permiso explícito
          controls.connect();
          statusEl.textContent = 'Giroscopio activo (sin permiso requerido)';
        }
      });

      // activar cámara (passthrough)
      document.getElementById('startCam').addEventListener('click', async () => {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio:false });
          cameraFeed.srcObject = stream;
          cameraFeed.style.display = 'block';
          renderer.domElement.style.zIndex = 1;
          statusEl.textContent = 'Cámara activa';
        } catch (err) {
          console.error('No se pudo acceder a la cámara', err);
          statusEl.textContent = 'Error cámara';
        }
      });

      // eventos para tap-to-place
      renderer.domElement.addEventListener('pointerdown', onPointerDown, { passive:false });
      // pinch-to-scale
      renderer.domElement.addEventListener('touchstart', onTouchStart, { passive:false });
      renderer.domElement.addEventListener('touchmove', onTouchMove, { passive:false });
      renderer.domElement.addEventListener('touchend', onTouchEnd, { passive:false });

      window.addEventListener('resize', onWindowResize);
    }

    function onPointerDown(ev){
      ev.preventDefault();
      // obtén NDC
      const x = (ev.clientX / window.innerWidth) * 2 - 1;
      const y = -(ev.clientY / window.innerHeight) * 2 + 1;
      // calcular dirección hacia el punto tocado
      const vec = new THREE.Vector3(x, y, 0.5).unproject(camera).sub(camera.position).normalize();
      const distance = 2.0; // metros aproximados
      const target = new THREE.Vector3().copy(camera.position).add(vec.multiplyScalar(distance));
      if (model) {
        model.position.copy(target);
        // ajustar sombra
        const shadow = model.getObjectByName('shadow');
        if (shadow) {
          shadow.scale.set(model.scale.x*2, model.scale.x*2, 1);
        }
        model.visible = true;
        modelPlaced = true;
        statusEl.textContent = 'Modelo colocado (tap)';
      }
    }

    // --- PINCH HANDLERS ---
    let lastDist = 0;
    function getTouchDist(t0, t1){ return Math.hypot(t0.clientX - t1.clientX, t0.clientY - t1.clientY); }
    function onTouchStart(e){
      if (e.touches && e.touches.length === 2) lastDist = getTouchDist(e.touches[0], e.touches[1]);
    }
    function onTouchMove(e){
      if (e.touches && e.touches.length === 2 && model) {
        e.preventDefault();
        const d = getTouchDist(e.touches[0], e.touches[1]);
        const factor = d / (lastDist || d);
        model.scale.multiplyScalar(factor);
        // limitar escala
        model.scale.clampScalar(0.05, 10);
        lastDist = d;
        const shadow = model.getObjectByName('shadow');
        if (shadow) shadow.scale.set(model.scale.x*2, model.scale.x*2, 1);
      }
    }
    function onTouchEnd(e){
      if (!e.touches || e.touches.length < 2) lastDist = 0;
    }

    function onWindowResize(){
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate(){
      requestAnimationFrame(animate);
      controls.update(); // DeviceOrientationControls
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
