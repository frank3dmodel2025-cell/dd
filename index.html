<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR Realidad Aumentada (AR) con Three.js</title>
    
    <style>
        body { margin: 0; overflow: hidden; }
        /* Estilo para que el botón de AR se coloque sobre la vista de la cámara */
        #ar-button-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
        }
        /* El canvas se creará automáticamente por Three.js */
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="ar-button-container"></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/GLTFLoader.js"></script>
    
    <script type="module">
        // Importar el módulo ARButton, esencial para iniciar y gestionar la sesión WebXR
        import { ARButton } from 'https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/jsm/webxr/ARButton.js';
        
        let scene, camera, renderer, controller;
        let reticle, duckModel; // Retículo para indicar dónde se colocará el objeto
        let hitTestSource = null;
        let hitTestSourceInitialized = false;

        // Modelo GLTF (el Pato original)
        const MODELS = {
            Duck: 'https://cdn.jsdelivr.net/gh/KhronosGroup/glTF-Sample-Models@master/2.0/Duck/glTF/Duck.gltf'
        };

        init();

        function init() {
            // 1. Configurar la Escena y la Cámara (WebXR controlará su posición en AR)
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

            // 2. Luces para la escena
            scene.add(new THREE.AmbientLight(0xffffff, 1.0)); // Luz ambiental
            scene.add(new THREE.DirectionalLight(0xffffff, 0.8)); // Luz direccional

            // 3. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.xr.enabled = true; // <--- Habilitar WebXR
            document.body.appendChild(renderer.domElement);

            // 4. Inicializar el Botón AR (para iniciar la sesión WebXR)
            const arButton = ARButton.createButton(renderer, { 
                requiredFeatures: ['hit-test'], // <-- Requerir la detección de superficies
                optionalFeatures: ['dom-overlay'],
                // Permitir que el botón de AR se coloque encima del contenido de la cámara
                domOverlay: { root: document.body } 
            });
            document.getElementById('ar-button-container').appendChild(arButton);
            
            // 5. Configurar el Retículo (el círculo que indica el punto de colocación)
            const geometry = new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2);
            const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
            reticle = new THREE.Mesh(geometry, material);
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle);

            // 6. Cargar el Modelo 3D (el pato)
            const loader = new THREE.GLTFLoader();
            loader.load(MODELS.Duck, function (gltf) {
                duckModel = gltf.scene;
                duckModel.scale.set(0.5, 0.5, 0.5); 
                scene.add(duckModel);
                duckModel.visible = false; // Ocultar hasta que se coloque en el mundo real

                // Centrar el modelo en su origen
                const box = new THREE.Box3().setFromObject(duckModel);
                const center = box.getCenter(new THREE.Vector3());
                duckModel.position.sub(center);
            });

            // 7. Configurar el Controlador de Interacción (tocar la pantalla)
            controller = renderer.xr.getController(0);
            controller.addEventListener('select', onSelect); // Evento 'select' es un toque en la pantalla o gatillo del mando
            scene.add(controller);

            window.addEventListener('resize', onWindowResize);
            renderer.setAnimationLoop(render); // <-- Usar el bucle de renderizado de WebXR
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Función que se llama cuando el usuario toca la pantalla
        function onSelect() {
            if (reticle.visible) {
                // Si el retículo es visible (se ha detectado una superficie), colocar el pato
                duckModel.position.setFromMatrixPosition(reticle.matrix);
                duckModel.visible = true;
            }
        }

        // El bucle de animación principal de WebXR
        function render(timestamp, frame) {
            if (frame) {
                const referenceSpace = renderer.xr.getReferenceSpace();
                const session = renderer.xr.getSession();

                // Inicializar Hit-Test Source (la fuente de datos para detectar superficies)
                if (!hitTestSourceInitialized) {
                    session.requestReferenceSpace('viewer').then((viewerSpace) => {
                        session.requestHitTestSource({ space: viewerSpace }).then((source) => {
                            hitTestSource = source;
                            hitTestSourceInitialized = true;
                        });
                    });
                }

                // Realizar Hit-Test para encontrar una superficie
                if (hitTestSource) {
                    const hitTestResults = frame.getHitTestResults(hitTestSource);

                    if (hitTestResults.length) {
                        // Se encontró una superficie: mostrar el retículo en esa posición
                        const hit = hitTestResults[0];
                        const pose = hit.getPose(referenceSpace);

                        reticle.visible = true;
                        reticle.matrix.fromArray(pose.transform.matrix); // Usar la matriz de transformación para mover el retículo
                    } else {
                        // No se encontró superficie: ocultar el retículo
                        reticle.visible = false;
                    }
                }
            }

            // Opcional: Rotar un poco el modelo una vez colocado
            if (duckModel && duckModel.visible) {
                duckModel.rotation.y += 0.01;
            }
            
            renderer.render(scene, camera);
        }

    </script>
</body>
</html>
